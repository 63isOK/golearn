# go 并发

传统并发是利用多线程来解决的，协程的概念很早就被提出来了，
只是21世纪才作为原生特性加到各个语言中，eg：lua和go。

go中提供协程是通过goroutines和channels。

没有协程时，进程是最小的资源管理单位，线程是最小的执行单位。
有协程后，协程是最小执行单位，而且协程不受内核调度，不用付出调度代价。

go中任何执行任务，都是用协程完成的。程序开始时，会用协程去调用main()

本章主题：
- 概念: 进程 线程 协程
- go中的调度
- 并发和并行
- 协程的创建
- 通道的创建
- 通道的读写
- 管道 pipeline
- 协程的等待

## 概念 进程+线程+协程

进程:
- 一个执行环境
- 包含 运行指令 + 用户数据 + 系统数据 + 运行时资源

线程：
- 轻量级的进程
- 由进程创建
- 有自己的控制流和stack

go中的协程goroutines：
- go中最小的执行单元
- 运行在线程中
- 最大的特征是`轻量`，一个程序可以跑几十万协程

## go调度

unix内核调度体现在程序的多线程调度。
go中的调度体现在协程上，还有个名字叫`m:n调度`，
n个线程上执行m个协程，其中使用到了多路复用。
调度器就负责协程执行的方式和顺序。

## 并发和并行

并发 不等于 并行

并行就是同时执行多个类型的实体，
并发在可能的情况下独立地执行她们。

并发的关键是有处理多个任务的能力，不一定要同时。
并行的关键是有同时处理多个任务的能力。

只有在程序的各个组件考虑到并发时，在并行时才能安全执行，
前提是操作系统和硬件支持，eg：多cpu情况下。

一个有效的并发设计，并发实体会让系统跑的更快，因为更多的在并行处理

并行的基础是一个良好设计的并发，外加合理解决问题的思路，
所以系统的设计阶段要多思考并发，是为了收益于潜在的并行

就算某些情况下我们不能收益于并行(eg:单核)，
并发也会让让程序的设计和维护大大提高。

## 协程

定义一个新的协程，可以用go关键字加上一个函数名，或匿名函数。

协程执行顺序依赖于操作系统的调度、go调度器、操作系统的负载。

匿名函数，更适合小函数，长函数还是使用常规函数

等待可以用sync.Add() sync.Done() 来等待，用的是计数器方式。
如果不一致会导致问题,Add多了会导致死锁，Done多了会导致异常


## channel

通道是一种通信机制，用于协程之间的数据交换，有以下规则：
- channel交换数据的具体类型是确定的，这也叫channel的元素类型
- 通过channel发送数据，同时需要有个接受者

可通过chan关键字来声明一个新的channel，close()来关闭

channel作为函数参数时，可以指定方向，方向决定收或发,
能确定方向的，尽量使用这个功能。
```go
    func f1(c chan int, x int)   // 双向
    func f1(c chan<- int, x int) // 只写
    func f1(c <-chan int, x int) // 只读
```

## pipeline

管道，go中的pipeline是一个虚拟方法，用于连接协程和channel。
目的是让协程的输出作为另一个协程的输入。和unix上的pipe概念上是一样的。

使用pipeline，可让设计简单，提高可维护性

pipeline的思想不在于所有的输入输出都是一样的，而是输出是另一个的输入，
windows的dshow，linux的gstreamer，unix的pipe，都是类似的思想

基于pipeline来设计程序，更加简单








