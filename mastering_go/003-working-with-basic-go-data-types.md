# 基础类型

本章重点是介绍基础类型
- array 数组
- slice 切片
- map

同时也会顺带介绍指针 常量 循环

展开的主题如下：
- array
- slice 以及比array的优点
- map
- pointer
- loop
- constant
- time和date包


## loop

go只提供了一种循环 for，格式上有很多变化而已

和c++类似，for中都可以使用break和continue

无限循环for ;; {} 可以简写成 for {}

i++和i--是语句，不是表达式，而且没有前置操作,
也就是说go中没有++i，--i，而且不能这么这么写： a := i--

## array

数组简单(理解简单，使用简单)实用(功能丰富，可存储多种类型的数据)

多维数组使用的时候一定要注意，避免出现bug
```go
    a := [2][3][4]int{
        {
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12},  // 不独立成行，eg：12，后面就不需要加,
        },
        {
            {
                1,
                2,
                3,
                4,  // 数组里的元素单独成行，一定要加,
            },
            {5, 6, 7, 8},
            {9, 10, 11, 12},
        },
    }
```

数组最大的问题是越界，但go编译器会给出提示

缺点：
- 大小是不能更改的，因为大小是类型的一部分
- 不能追加数据，因为大小不能更改
- 数组充当函数参数时，是拷贝副本，是传值，不是传址
- 数组很大，充当函数参数时，效率低，因为传值

所以go中使用数组很少,都是用切片

## slice

能使用数组的地方，就能使用slice，毕竟slice就是为了代替数组而设计的。

在函数参数使用slice，是传址

可以直接用var声明一个slice 字面量，也可以使用make([]int, 20)

- 追加使用append
- 访问可以使用slice[index]
- 可以从已存在的slice中创建一个新的： s := slice[1:3],这个操作称为`重新切片`

重新切片，并没有申请新的空间，还是指向之前的数组

切片，重新切片，中间涉及的概念很多，数组，原始切片，重新切片，
其中切片的两个属性会跟这些概念都有关系：
- capacity 容量
- length 长度

长度是半开区间中元素的个数，
容量是第一个元素对应到数组中，到数组结尾时中间的元素个数

当slice的容量用完之后，go会自动将容量翻倍(*2),
测试发现，重新切片的slice，如果容量变化了，他对应的数组就是新的一个了,
不管是原始切片还是重新切片段的

切片和数组类似，同样是有多维切片的，
不过多维切片使用多了，证明设计还是需要重构

## map

map是hash table数据结构，map的好处是任意类型都可以作为其索引，
这个索引，也被称为map中的key，key需要支持比较，也就是说要支持 == 操作。

浮点型作为key，有可能引起精度问题，这是不同机器，不同操作系统导致的。

取值，m[a] 如果a不存在时，返回0

当一个map是nil时，只有增加会报异常，其他删查遍历都没问题

map在灵活的同时，带来了高消费，这体现在map的实现上，
不过go中的map已经很高效了。

## const

常量，是全局的，如果局部的常量定义太多，需要重新考虑设计

常量定义在编译时，而不是在运行时

常量写法，也支持因式分解写法

常量较多的情况下，可以把这些常量放到一个单独的package中

const中还将枚举的写法兼并了
```go
const (
  a = iota
  b
  c
)
// 等同于
const (
  a = 0
  b = 1
  c = 2
)
```

iota也可以参与到表达式中

## pointer

指针

## time date


