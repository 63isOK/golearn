# 并发的高级主题

前面介绍了go中最重要的特征：原生支持的协程，
也用到了channel和pipeline，本章会更加深入

主题包括下面几个：
- select关键字
- go调度器的工作方式
- 协程中的两种超时方式
- 信号通道 缓冲通道 nil通道
- 协程监控
- 通道的通道
- 共享内存和互斥量
- sync.Mutex 和sync.RWMutex类型
- context包
- 工作池
- 检查竞争条件

## 再次聊到go调度器

前面聊到调度器的技术是m:n调度，就是说m个协程跑在n个线程上。

--- 理论
go中用的是fork-join并发模型，就是说将一个任务拆分成多个小任务，
多个小任务分别放到几个任务队列里，每个队列用一个线程跑，
当线程跑完了，如果其他队列还没跑完，就可以帮忙去消灭一个任务，
这个也叫任务偷窃，有个任务偷窃算法对应，
直到所有队列的小任务都完成，最后将结果合在一起，并返回。

fork-join模型是一种分治法。
go中的fork部分就是创建分支，join部分就是分支结束时进行结果合并。

go中的每一个协程都可以看成一个任务task，她的处理者就是线程。
处理者的负载就是fork-join中队列中的任务数，
说白点就是线程中带执行的task数量，也就是协程数量。

公平调度策略，就是让可用处理者的负载基本一致，
简单点讲就是让所有的处理者的占用保持一致即可。
而实际情况则是：很多分布式的任务都是依赖其他任务的。
所以到目前为止，很多处理者都是未完全利用的。

那么go是怎么尽量提高处理者的利用的呢：fork-join并发模型。
就是提高线程的利用效率，多个线程(处理者)处理自己任务队列，
当自己的队列完成了，就看看其他线程是否完成，视情况偷窃，
这样保证了每个线程的利用率。这里就有个任务偷窃策略。

任务偷窃策略，每次偷窃，有两种颗粒：
- task，就是一个协程
- continuation， 调用协程之后，后面所有的事，简称`后续`

由于在go中窃取`后续`比窃取协程(任务)发生次数要多很多，
所以窃取算法是基于`后续`来做的，而不是协程

基于`后续`来窃取，坏处是编译器要多做额外的工作，
好处是使用单个函数或单线程多协程的返回结果是一样的。

--- 理论

说了这么多，还是回到go的m:n调度：
在go中有3个实体：线程 协程 逻辑处理器

    逻辑处理器是什么：
    物理cpu个数：主板上实际插入的cpu数量
    cpu核数：cpu上能处理数据的芯片组数量，eg：双核 四核
    逻辑cpu：一般是物理cpu个数 * 核数，如果支持超线程技术，那再 * 2

go中的逻辑处理器，实际上已经利用到了所有的系统资源。

前面将到的m:n调度，只说到了线程和协程之间的调度。
下面说下线程、协程、逻辑处理器之间的关系：
- 任务队列分2种：
  - 局部队列，逻辑处理器内部的队列
  - 全局队列，将全局队列的协程丢给局部队列，
    说白了就是全局队列给每个处理器分任务
- go调度器要检查全局队列，避免协程丢错到不该丢的处理器，
  因为不能任何时候都检查，所以全局队列并不比局部队列有优势
- 一个逻辑处理器有多个线程跑
- 偷窃只会出现处理器的局部队列

go调度器能创建很多线程，不过线程非常昂贵，多了会导致整个程序变慢，
所以协程不是性能的万灵药。

协程比线程运行更快，这个理解是错误的，协程只是增加了更多的并发性，
如果有多个逻辑处理器，就会有更多潜在的并行，这就是好处。
这就是go宣称的，在多处理器多核架构上有优势的地方。

程序可以使用几个逻辑处理器，可用GOMAXPROCS环境变量指定,
也就是说可以同时执行几个线程，go1.5默认使用所有的核。

## select

好处是一个select可以处理多个channel，坏处是死锁

select 不需要default分支

select最大的好处是对多channel的管理 连接 和配置

## 协程超时

select中使用time.After(1 * time.Second)

## 再次聊到channel

- channel 的0值是nil
- 给已关闭的channel发送消息，会包异常
- 从一个已关闭的channel读消息，读通道类型的0值
- 要关闭一个channel，channel不能是只接收
- nil channel会阻塞
- 关闭nil channel 会包异常

### buffered channel

利用这种通道，go调度器可以将job快速放到队列，以达到处理更多请求。
此外还可以将缓冲通道作为信号，来限制程序的吞吐量

select语句中可以使用default来处理buffered channel的读完或写满操作

### nil channel

将一个channel赋值为nil 就是nil channel，此时读写会阻塞

### channel of channel

非常特殊的通道，通道类型是通道

make(chan chan int)

这种通道，一般很少用。

for range channel: 这种用法表示要等待channel close就进入for循环

chan chan 这种用法和c中的指针的指针类似

### signal channel

信号通道，不是用于传输数据，而是用来发送结束信号，
这个结束信号可以是bool型，也可以是struct{}，也可以是任何定义的，
使用struct{}来充当信号通道的类型，是因为不用传数据，减少bug和二义性

信号通道还有一个用处：控制协程执行顺序。

带顺序的协程和函数的区别：
- 都是有顺序的
- 协程有并发，函数没有
- 所有协程都是有顺序，那还不如用函数

利用channel读写的阻塞性，可以控制协程执行的执行顺序，一般没有必要不会这样做。

## 共享内存和共享变量

说白了就是同步，对资源的同步用sync.Mutex,
如果是等待协程，可用sync.WaitGroup

如果sync.Mutex.Lock()之后未解锁，再次加锁会导致死锁

sync.RWMutex是另一种互斥量，功能更加高级一些，支持一写多读，
需要注意的是：在读的互斥全部解锁之前，写的互斥不能加锁。

如果要看运行时间，可在用time go run xxx

对于变量，使用sync提供的互斥两/读写互斥量就可以搞定，下面说下共享内存：
sharing by communicating instead of communicating by sharing，
说的是`不要通过共享内存来通讯，而是通过通讯来共享内存`，
go中提供一个监控协程，这个监控协程拥有这个共享内存的数据，
其他协程要获取共享内存的数据，就需要发消息和监控协程交互。对应上面的英文。

这个哲学更多的用于线程间的共享内存, 进程间的共享内存的情况还未遇到，可能是c调用可能是其他

## 数据竞争条件

出现数据竞争的条件：
- 两条或多条指令要访问同一内存地址
- 至少一条指令是修改指令

在使用go build或go run时，要开启竞争检查，需要加-race 标识

竞争检测器是基于c/c++的ThreadSanitizer运行时库，用于找出竞争条件。
在chromium和go标准库中捕获到很多竞争条件，使用的是插桩方法，
这样会导致程序运行变慢，所以适合用作测试。

这个是并发排错的重要工具.如果不用-race，部分竞争是可以直接暴露出来，部分不会，
所以，不管如何，写完代码，最好用-race检测一下竞争条件。

## context 包

主要是用于支持取消，eg：http请求

上下文，用于一些长时间处理(界面 网络请求等)的取消，
在网络编程中很常见。

## worker pools

池，线程池 资源池都是有特定的用处

go中的工作池是指线程集合。

apache的web服务是这样的：一个主处理逻辑接受所有的请求，
然后分发给各个工作处理逻辑去处理，由工作处理逻辑提供服务。

go中也是类似，不同之处：一个线程池，一个是协程池

这些池化技术的好处是：工作处理逻辑完成一个job后，并不释放自身的资源，
这样减少了在"资源申请和释放的"过程中的消耗，这个消耗很大。

但在go的工作池中，资源是要释放的，因为使用协程的代价很低，
这也是和其他池的第二个区别。

池化技术另一个好处是工作处理逻辑的数量是可控的，
就像不管池大池小，总有池塘边缘。
eg：服务器上有两个服务都使用了池化技术，一个核心服务设置为80%，
边缘服务设置为10%，某一时刻，访问边缘服务的有10000请求，
访问核心服务的就算只有10个，也不影响。

go中的协程池利用到池的限制作用。

利用buffered channel来实现pools。








