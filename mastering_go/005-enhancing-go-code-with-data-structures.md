# ds 数据结构

前面介绍了基础类型，和上一章的复杂类型

本章的重点在于更加真实的数据结构，
包括二叉树、链表、hash表、栈、队列

本章主题主要包括以下几个：
- graph 和 node
- 计算算法复杂度
- 二叉树
- 哈希表
- 链表
- 双向链表
- 队列
- 栈
- container标准包中的数据结构
- 随机树的产生
- 难破解的密码


## graph and node

图，一种数据结构，
图G = 顶点V(node) + 叶子E(edge)

图分两种：
- 循环图 全部或部分node组成一个闭合的链
- 非循环图 没有闭合的链

有向图：叶子有方向的。有向非循环图没有闭合的链

## 算法复杂度

算法的评价依据是计算复杂度，
O(n) 比 O(n2) 好

## 二叉树

二叉树，一个node下最多有两个子node

二叉树的应用场景是：要表达分层数据时，
好处是：树自带排序，还出是删除尽量少做

树的深度，也就是叶子的最大层数，
平衡二叉树，最大叶子深度和最小叶子深度相差不超过1

平衡一个已有二叉树很困难，最容易的是创建的时候就创建一个平衡二叉树。
平衡二叉树的复杂度是log(n),深度是log2(n),

- 10000, 高度是14
- 10w，高度是17
- 100w，高度是20，意思是100w的数据中查找一个值，20次就ok了，
这就是为啥二叉树效率那么高，应用那么广。平衡二叉树的效率非常高，非平衡的效率未知

平衡二叉树在搜索时灵活性非常高,非常高效，她的形状取决于数据加入的顺序，
所以key如果很长很复杂，那么搜索的效率也会很低。

当然某些链表和数组的读取速度比二叉树高，但搜索的时候还是二叉树高。




