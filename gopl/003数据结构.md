# 数据结构

内置数据类型的设计要考虑两方面：
- 硬件特性
- 表达复杂数据结构的便捷性

go的数据结构分4类：
- 基础类型 eg：数字 字符串 bool型
- 复合类型 eg：数组 结构体
- 引用类型 eg：指针 切片 字典 函数 通道
- 接口类型 eg：接口

## 数字之整形

--|--|--|--
int8 | uint8 | 8bit | 1byte
int16 | uint16 | 16bit | 2byte 
int32 | uint32 | 32bit | 4byte 
int64 | uint64 | 64bit | 8byte 

int和unit依据平台位数来决定，64位对应int64,32位对应int32

rune unicode字符，和int32等价； byte和int8等价

uintptr用于存储指针，只有在底层编程才会用到，eg：go和c互调，
位数并不确定。

二元算术运算的5种优先级：
- 乘除 取模 左移 右移 按位与& 按位置0:&^ 
- 加减 按位或| 按位异或^
- 比较运算 等于 不等于 大于 小于 等
- 逻辑运算&&
- 逻辑运算||

```go
fmt.Printf("%[1]v, %[2]v", a, b) // []表示使用第几个操作数(参数)来对应

// % d, %和d之间如果有空格，打印的时候会在前面打印一个空格

for i:=0; i < len(字符串); i++  {} // 字符串[i] 的类型是byte，uint8
for _, x := range 字符串 {} // x类型是rune，int32
```
基本字符(可见+不可见)常见的就是0-255之内的，用1byte表示即可，
unicode，用1-3个byte表示，支持中日韩文字，
常规for时，是按字节遍历；for range时，是按unicode字符遍历

for range 遇到中文，索引不是连续的，会出现跳跃的情况,
如果要计算字符串的字符有多少个，可用utf8.RuneCountInString(),
或者使用 n:=0; for range str {n++}获得

## 数字之浮点型

float32 提供9位精度，包括小数点  
float64 提供18位精度，包括小数点， 她们都会自动做四舍五入

太大的数或太小的数最好用指数方式表示

## 数字之复数

x := 1 + 3i

## 布尔型

## 字符串

字符串不可修改，底层应该和数组的实现类似，这让复制的代价变低

- ""包含的字面量，里面可以有转义
- 反引号包含的字面量，原生字面量，里面不会进行转义，写正则表达式时会用到、html模板、json字面值、命令行信息、多行的场景

标准库提供了4个包来处理字符串：
- bytes
- strings
- strconv
- unicode

进制转换，输出字符串时，使用fmt.Sprintf比strconv.Format更方便一些,
将字符串解析为整数，用strconv更方便，特别是转成uint，

## 常量

批量声明时，第一个常量的初始化表达式不能省略，其他都可省略，
如果省略了，就使用前面常量初始化表达式写法，注意 只是写法继承了，字面量也继承了，
如果遇到iota，表达式写法也是一样的。

iota，常量生成器，在第一次出现时，为0，后面遇到的每一行，加1，
遇到新的iota，则重置为0

无类型常量的好处：
- 更高的精度
- 无需显式类型转换而可以应用于更多表达式

无类型常量在表达式计算中，会隐式转换成相应的类型

## 复合类型之数组

数组初始化时，var abc[...]int = [1]int{1}, ...表示根据初始化的值的个数来确定

- 数组的长度需要在编译器确定下来
- 数组作为函数参数时，不是引用，而是副本，这和c/c++是不一样的
- 数组的长度是类型的一部分，是不能更改的，所以没没法删除其中一些值

```go
    var a[...]int = [1]{1}
    b := [...]int{10:123}  // 数组有10个元素，最后一个是123
```

## 复合类型之结构体

## 引用类型之切片

底层还是使用数组，相对数组来说，增加了很多灵活性的功能

slice由3部分组成：
- 指针 指向第一个slice元素对应底层数组元素的地址
- 长度 slice元素个数
- 容量 slice的开始位置到底层数据的结尾位置，长度超过这个值就需要重新申请数组了

## 引用类型之map

map 底层用的是hash，

## 引用类型之函数

## 引用类型之通道

