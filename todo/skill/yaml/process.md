# 处理yaml信息

本节主语介绍yaml的组成部分

- yaml既是一个文本格式，也是一个方法(将原生数据格式转换成文本格式的方法)
- 所以yaml spec中对yaml定义了两个概念
  - 数据对象的类，用于yaml的表现(tagged nodes有根/连接/有向图)
  - 一种语法(将yaml的表现作为一系列字符串呈现出来)，叫yaml流
- yaml处理器就是一套工具，将yaml表现和yaml流之间做转换
- 使用yaml处理器的其他模块叫程序

本节主要围绕yaml信息结构，这些信息由yaml处理器或程序提供

yaml信息要么给机器用，要么给人用
- 所以yaml信息有3种状态：
  - representation 表现，是一个由root节点/连接线/有向图组成
    - 用于解决 原生数据结构和编程环境之间的移植转换
  - serialization 序列化树，
    - 关注于将representation转换成一个串行格式(这个格式需要顺序访问)
  - presentation 流，人类可读
    - 将serialization处理为一系列人类可读的字符

## 处理

- 原生数据结构和字符流之间的转换要经过几个逻辑阶段
- 每个阶段都定义好了输入输出的数据模型

处理过程描述：
- yaml信息主要有4个不同的状态：
  - 原生数据结构 native data structure， 对应编程环境中的数据结构
  - 节点图 node graph，对应representation
  - 事件树 event tree，对应serialization
  - 字符流 character stream，对应presentation
- 4个状态中有3种转换
  - 数据结构 --represent--> 节点图 --serialize--> 事件树 --present--> 字符流
  - 数据结构 <--construct-- 节点图 <--compose--   事件树 <--parse--   字符流
- yaml处理只需要对外暴露字符流阶段即可
  - 从数据结构到字符流，叫dump
  - 反过来，从字符流到数据结构，叫load

dump的三个阶段：
- 第一阶段，转成节点图
  - 利用3种节点(node)来映射数据结构
    - sequence，序列，可理解为数组
    - map，kv对
    - 字面量
  - 这些原语组合成有向图结构
    - sequence对应很多编程语言中的数据和列表
    - map对应hash表，字典
    - 字面量对应 string int date 以及其他数据类型
  - 节点node，包含(类型/内容/用于指明数据类型的tag)
- 第二阶段，序列化成事件树
  - 对于要顺序访问的媒介(元素)，需要序列化成一个有序树
  - map是无序的，一个node可能被引用多次
    - 所以序列化操作对key要强加一个排序
    - 对于第node的第二次及后面的引用，都用一个别名占位符来代替
  - yaml sepc对具体的序列化细节并未规定
  - 序列化完之后就是序列化的树了，这个树叫事件树
- 第三阶段，转字符流
  - yaml提供了多种可选风格，来让字符流更具有可读性
  - 所以在这个阶段，yaml处理器就需要更多信息：
    - 选择哪种node风格
    - 字面量格式
    - 缩进
    - 使用哪些tag
    - 未指定的保留tag
    - 提供哪些指令集
    - 添加注释时可能的事件
  - 有时，上面部分信息由程序决定，有时，需要让用户按自己的喜好来选择

load是dump的逆向，将可读性的字符流转换成程序的额数据结构：
- 第一阶段，解析
  - 将字符流解析为一系列事件
  - 解析时不用关心那么多可选风格，只需要将当前风格的数据解析为序列化事件即可
  - 解析可能会失败(eg：错误的格式会导致失败)
- 第二阶段，组合成图
  - 组合成节点图也可能会失败，具体失败原因会在后续展开
- 第三阶段，构造数据结构
  - 构造时会丢弃很多附加信息：
    - 注释
    - 指令
    - map的有序key
    - node风格
    - 字面量内容格式
    - 缩进等级
  - 构造阶段也可能会失败(eg：找不到语言对应的数据结构)



