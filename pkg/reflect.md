# reflect

反射

反射是程序检查自身结构的能力，特别是对类型来说。
是元编程的一种形式。

每种语言实现反射的手法都不一样，下面说的是go中的实现。

go中的反射是基于类型系统的

go是静态类型的，什么是静态类型：编译期，变量的类型就是已知并固定的

```go
    type myint int
    var i myint
    var j int
```
i和j的类型是不一样的，没有显示类型转换，两者之间是不能赋值的。

接口是一种类型，她表示方法的集合，接口变量可以存储任意类型的具体值，
前提是这个值满足接口的约束(就是实现了接口中所有的方法)，

interface {}  这个接口类型最极端了，所有的变量都满足这个接口

## 接口的表示

接口变量 = 具体的值 + 具体值的类型

反射规则：
- 从接口变量到反射对象的反射
- 从反射对象到接口变量的反射
- 要修改一个反射对象，接口变量需要能被设置

下面具体讲解上面的规则

## 接口变量到反射对象

初级用法，仅仅是确定接口变量存储的值和值的类型

reflect包中定义了两个类型： Type和Value

通过reflect.VauleOf() reflect.TypeOf() 来获取具体的值和值的类型

## 反射对象到接口变量

通过反射，利用reflect的Value和Type 推导出接口变量

reflect.Value.Interface() 可返回一个接口对象

## 具体值可以被设置，那么就可以修改反射对象

settability 这是个Value的属性，是个开关，
默认是false，如果是true，就表示具体值可以被修改

reflect.ValueOf(&x).Elem().SetFloat() ,
第一 传值，第二 Elem()，这样才可以修改值，不然不行

如果是结构体：

需要注意，如果x是结构体，如果结构体里的是小写，那么Set函数是不行的，
因为小写的作用域，Set函数执行会失败，要大写
