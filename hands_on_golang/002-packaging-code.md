# 代码的打包

主要关注的是代码组织的方式
- 项目组织
- 包
- 面向对象
- 结构化测试


## 约束

模块化设计有一方面叫约束

组件交互的格式化文档，就是约束，可以是接口，api，或协议，
如果约束修改了，架构师需要确保下面几件事：
- 约束是持久被动的，修改不会放大
- 约束是可归档的,向后兼容需要考虑到
- 约束要考虑到非功能性需求, 这就是服务级协议

## 面向对象

面向对象有很多方法来降低复杂度，
核心3刀是封装，多态，继承

不过继承也有不好的方面：基类的修改会引起连锁反应，
重要的是基类并不关心或不知道派生类，一般基类很少能变动的。

代替继承的方式是委托，也被称为组合，
c++里的委托是类中包含另一个对象的指针，组合是类中包含另一个对象，
这里从架构上将就不像c++分那么细(果然c++无所不包)，委托也就是组合

那怎么实现委托？
- 如果是约束，将让基类来提供(这部分还是走类继承)
- 可重用的，功能性的，使用对应的引用来提供

这就是`组合优于继承`的原则，这也是go推荐的方式

    c++提供了十八般兵器，go只提供刀
    go说：现在是战争年代，刀是杀伐之王，用我可建功，我最实用
    c++提供了十八般刀法，go只提供了斩马刀法
    go说：现在的争端在沙场，斩马刀法可建功，我最实用
    c++提供了十八般斩马刀式，工只提供了竖劈
    go说：现在简单杀招最常用，起手只要一瞬间，我最实用

上面说的都是笑话，go不是c++的子集，她们都是解决问题提出的两种可能。

委托还有一点好，内存占用，因为是引用对象，到了使用时才会初始化引用对象，
这样就算内存资源优化，ps：c++的委托和组合的区别也在这一点。

go中的面向对象
- struct类型承载了封装的意义
- struct中的值就是属性
- 方法就是struct的成员函数
- 可见性，go中使用首字母大小写来设置
- 接口实现了多态
- go中的嵌套，可视为多继承；多重嵌套可视为多重继承  
    嵌套是组合，和继承还是有不同的

在c++或其他语言中，接口是抽象的，实现是明确指出的，
go中实现是隐含的，只要对象实现了接口中定义的方法，那么这个对象就实现了接口，
go中的接口是一个类型，其他语言总接口是一个概念。

只要类型A的方法集中包含了接口B的方法集，那么称A实现了接口B，
A可以是一个非接口类型，`也可以是一个接口类型`

## 模块

go通过package来将细节封装，暴露和不暴露通过大小写来控制，
这种约定符合`惯例优先原则`

代码布局 code layout, 三方库依赖，框架

为了减少第三方库的影响，可以使用以下手段：
- vendor目录下检查所有依赖
- 每个项目有各自的工作区
- 使用makefile

三方库不建议以子模块仓库(git)的方式加到项目中

自己写的库(公司内部用的库)对项目来说也是三方库，需要注意以下几点：
- 配置外部化
- 日志需要结合上下文
- 尽可能避免自己处理错误，要定一些约束和触发手段

## 测试

影响易测性的几个方面：
- 代码是否可以尽早测试
- 有独立并可重复的测试

    按逻辑分成多个package，完成一个包就测试一个
    如果有包的测试依赖另一个，可以使用gomock进行模拟

结构化测试 - 表格驱动测试  
重用性高，增加新测试只需要增加表记录，
go也很支持这种表格驱动测试，
自动化测试让开发变得更加快速，更加轻松

