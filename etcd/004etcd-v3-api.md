# etcd v3 api

etcd v3 版本的发布标志着数据模型和api的正式稳定。

- kv api支持了mini事务
- 提供了一套v3的api，v2和v3的api共享同一套raft协议代码，v2和v3可以看成raft协议代码行的两个应用，相互独立
- 效率、可靠性、性能上进行了优化

v3基于v2的改进和优化：
- grpc + pb 取代 http + json
- lease租约，更轻量级的自动过期机制，取代了key的ttl自动过期机制
- watcher 观察者机制重新设计，v2的机制基于http长连接事件驱动机制，v3机制基于http2的server push，对事件有多路复用优化
- v3数据模型改进，v2是一个kv内存数据库，v3支持事务和多版本并发控制的磁盘数据库。

## 重要特性

grpc
- google开源的高性能、跨语言的rpc框架
- 基于http2协议实现
- 使用bp进行序列化，数据模型和rpc接口都基于pb

pb
- 效率高于json，差不多两倍多

减少tcp连接
- 利用http2的多路复用，减少通信

租约机制 lease
- 多个过期时间相同的key，绑定一个租约，客户端维护这个租约即可，不用维护每一个key

观察者模式
- 服务端通知客户端，而不是客户端去轮询(zookeeper/consul就是轮询)
- 轮询：一次性watch，会导致用户无法感知两次watch之间发生的事件。etcd可以通过索引轮询和流式观察来解决这个问题
- v2的索引轮询，每次轮询都有一个http长连接，v3对一个客户端进行多路复用，减少服务端压力

数据存储模型
- v2只保存key最新的value，历史记录放在缓冲中(只有1000个，而且是全部key共享的)
- v3放弃了v2这种滑动窗口的设计，引入了mvcc(多版本并发控制)，采用了从历史记录为主索引的存储结构
- v3放弃了v2的目录式层级化设计，而使用了一个扁平化的设计
- v3采用了mvcc，保存了k-v的历史版本，数据大了很多，就从内存数据库转为磁盘数据库，底层存储引擎是 BoltDB,最后采用的是coreos维护的。

mini事务
- v3除了提供kv api，还提供了 事务api，v2提供了cas/cad来对单个key进行更新
- v2的cas/cad操作依赖提供具体版本号或当前值，一旦条件不满足，操作就会失败，而且多个key变更时，v2力有不逮
- v3引入mini事务来解决分布式锁和事务。v3 v2的差异是，v2的操作适用于单个key，v3适用于多个key

快照
- v2是内存数据库，最多支持数十万级级别的key，不是说不能支持更多，而是raft一致性是基于日志，日志不能无限增长，到一定程度就要存快照，持久化到磁盘
- v3对raft和存储系统进行了重构，支持增量快照和传输较大的快照，目前v3支持百万到千万级别的key

大规模watch
- v2中每个watch都占用一个tcp资源和一个go协程资源，差不多30k-40k
- v3使用http2的多路复用，同一个用户不同watch共用一个go协程，减少了服务器资源消耗



